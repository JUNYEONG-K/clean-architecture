# 벽돌부터 시작하기: 프로그래밍 패러다임

소프트웨어 아키텍처는 코드로부터 시작한다. 따라서 아키텍처에 대한 논의도 코드가 최초로 작성된 시점부터 출발하자.

1938년 앨런 튜링은 지금 우리가 컴퓨터 프로그래밍이라고 부르는 분야의 토대를 쌓았다.
1945년 앨런 튜링은 바이너리 언어를 사용해, 프로그램을 실제 컴퓨터에서 코드로 작성했다.
반복문, 분기문, 할당문, 서브루팅, 스택 등 우리에게 익숙한 구조를 사용했다.

이후로 프로그래밍에는 수많은 혁신적인 변화가 이뤄졌다.
1940년대 후반 어셈블러가 처음으로 등장했고, 이로 인해 바이너리 코드로 프로그램을 작성해야 했던 프로그래머의 단조롭고 고된 일이 줄어들었다.
1951년 그레이스 호퍼는 최초의 컴파일러인 A0를 발명했다. 1953년 포트란의 발명을 시작으로 새로운 프로그래밍 언어는 쉴 틈 없이 홍수처럼 쏟아졌다.

또 다른 중요한 혁신적인 변화가 프로그래밍 패러다임에도 몰아쳤다.
패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.
패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다.

* 구조적 프로그래밍: 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
  * 1968년 에츠허르 비버 다익스트라(Edsger Wybe Dijkstra)가 발견했다. 
무분별한 점프(goto 문장)는 프로그램 구조에 해롭다는 사실을 제시하면서, if/then/else 와 do/while/until 과 같이 더 익숙한 구조로 대체했다.
* 객체지향 프로그래밍: 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
  * 1966년 요한 달(Ole Johan Dahl)과 크리스텐 니가드(Kristen Nygaard)에 의해 등장한다. 
알골(ALGOL) 언어의 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했다.
바로 이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 그리고 중첩 함수는 메서드가 되었다.
함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장하게 되었다.
* 함수형 프로그래밍: 할당문에 대해 규칙을 부과한다.
  * 최근에 들어서야 겨우 도입되기 시작했지만, 세 패러다임 중 가장 먼저 만들어졌다. 컴퓨터 프로그래밍 자체보다도 먼저 등장했다.
알론조 처치(Alonzo Church)는 어떤 수학적 문제를 해결하는 과정에서 람다 계산법을 발명했는데, 함수형 프로그래밍은 이러한 연구 결과에 직접적인 영향을 받아 만들어졌다.
1958년 존 매카시(John McCarthy)가 만든 LISP 언어의 근간이 되는 개념이 바로 이 람다 계산법이다.
람다 계산법의 기초가 되는 개념은 불변성(immutability)으로, 심볼(symbol)이 전혀 없다는 뜻이기도 하다.

각 패러다임은 프로그래머에게서 권한을 박탈한다.
어느 패러다임도 새로운 권한을 부여하지 않는다.
각 패러다임은 부정적인 의도를 가지는 일종의 추가적인 규칙을 부과한다.
즉, 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.

세 가지 패러다임은 우리에게서 빼앗아갈 수 있는 모든 것들을 빼앗아간다. `goto문, 함수포인터, 할당문`
이 외에는 우리로부터 빼앗아갈 수 있는 것이 없고, 그렇기 때문에 앞으로도 프로그래밍 패러다임은 이 세 가지만 존재할 것이다.
실제로 1958년부터 1968년까지 10년에 걸쳐 만들어진 세 가지 패러다임 외에 지금까지 몇 십년동안 새로운 패러다임은 나타나지 않았다.

아키텍처와 패러다임은 어떤 관계가 있는가?
우리는 아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성을 이용한다. 우리는 함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대해 규칙을 부과한다.
우리는 모듈의 기반 알고리즘으로 구조적 프로그래밍을 사용한다.

세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.

## 구조적 프로그래밍
다익스트라 당시 프로그램은 단순할지라도 인간의 두뇌로 감당하기에는 너무 많은 세부사항을 담고 있었다.
아주 작은 세부사항이라도 간과하면 프로그램이 동작하는 것처럼 보이더라도 결국엔 예상 외의 방식으로 실패한다.

다익스트라는 증명(proof)이라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다.
그의 비전은 공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층구조를 만드는 것이었다.
그는 수학자가 유클리드 계층구조를 사용하는 방식을 프로그래머도 사용할 수 있다고 믿었다.
다시 말해 프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 그래서 코드가 올바르다는 사실을 스스로 증명하게 되는 방식이다.

다익스트라는 이 연구를 진행하면서 `goto 문장`이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다.
만약 모듈을 분해할 수 없다면, 합리적으로 증명할 때 필수적인 기법인 `분할 정복 접근법`을 사용할 수 없게 된다.

반면 `goto 문장`을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우도 있었다. 이 좋은 사용방식이 바로 `if/then/else 와 do/while`과 같은 분기와 반복이라는 단순한 제어구조에 해당한다.
모듈이 이러한 종류의 제어 구조만을 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화하는 것이 가능해보였다.
이러한 제어구조와 순차 실행(sequential execution)을 결합했을 때 더 효과적이다.

실제로 goto 문장은 프로그래밍 언어가 발달하고 시간이 흐름에 따라 사라졌다.

구조적 프로그래밍을 통해 모듈의 기능적 분해가 가능해졌다. 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있게 된 것이다.
그리고 각각은 다익스트라가 말한 입증할 수 있는 아주 작은 기능들로 세분화될 수 있었다.

하지만 실제로 다익스트라가 꿈꿨던 수학적 증명은 이루어지지 않았다. 
세세한 기능 하나하나를 엄밀히 증명하는 것이 고품질의 소프트웨어를 생산하리라고 믿는 개발자도 이제는 없다.
대신 우리는 과학적 방법을 택했다.

### 과학적 증명
과학은 근본적으로 수학과는 다르다. 뉴턴의 운동 제2법칙인 F=ma 혹은 만유인력의 법칙이 옳다고 증명할 수 있는 사람은 없다.
그저 이 법칙을 시연할 수 있고, 이들 법칙을 소수점 이하의 많은 자리의 정확도로 측정할 수 있을 뿐, 수학적으로는 증명할 수 없다.
수많은 실험과 경험적 증거 또한 이들이 옳다고 증명할 수 없다. 언제든 다른 실험을 통해 운동 법칙 혹은 만유인력의 법칙이 잘못되었음이 밝혀질 수 있다.

과학적 이론과 법칙이 지닌 본성은, 반증은 가능하지만 증명은 불가능하다는 것이다.
반례를 들 수 없다면 우리는 꽤 신뢰한다.

### 테스트
다익스트라는, '테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다'라고 말했다.
프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.
그럼에도 우리는 테스트에 충분한 노력을 기울여, 테스트가 보장할 수 있는 범위 내에서 프로그램이 목표에 부합할만큼은 충분히 참이라고 여기게 된다.
과학적 증명을 따른 것이다.

소프트웨어 개발이 수학적인 구조를 다루는 듯 보이더라도, 실질적으로는 수학적인 시도가 아니라는 것이다. 오히려 과학과 같다.
올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문이다.

구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다.

가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다.
소프트웨어 아키텍트는 모듈, 컴퓨넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.

## 객체 지향 프로그래밍
객체 지향이란 무엇일까?

누군가는 "데이터와 함수의 조합"이라고 답할 수 있다. 그렇다면 `o.f()`와 `f(o)` 는 다르다는 것일까? 
객체의 함수를 콜하는 것과 함수에 객체를 넣는 것, 이 둘은 모두 데이터와 함수를 분리하고 조합한 것들이다. 객체 지향이란 무엇인가에 대한 대답으로는 그닥인 것 같다.

"실제 세계를 모델링하는 새로운 방법"이라는 대답도 충분히 나올 법하다. 이 말의 의미가 정확히 무엇일까? 우리는 왜 그것을 추구해야할까?
이 답변의 의도는, 객체 지향은 현실 세계와 의미적으로 가깝기 때문에 객체 지향을 사용하면 소프트웨어를 좀 더 쉽게 이해할 수 있다는 것이다.
하지만 의도가 꽤나 불분명하고 모호하다.

`캡슐화 encapsulation`, `상속 inheritence`, `다형성 polymorphism` 의 용어를 활용해서 답변하기도 한다.
객체 지향은 세 가지 개념을 적절히 조합한 것이거나, 최소한 세 가지 요소를 반드시 지원해야한다면서.
그럼 다음 세 가지 개념에 대해 알아보자.

### 캡슐화
캡슐안에 숨기는 것이다. 외부로 정보를 노출하지 않는 것이다.
대부분의 것들을 캡슐 안에 숨겨 은닉화하고, 일부만 노출한다. 그리고 노출된 일부로 서로 소통한다.
하지만 실제로 완전한 캡슐화는 시간이 지나면서 무뎌지고 있다.
특히 C에서 OO 언어로 넘어가면서 그 현상은 점점 심해졌다.

### 상속
OO 언어가 더 나은 캡슐화를 제공하지는 못하지만, 상속만큼은 확실히 제공한다.
상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다.
이는 C 언어에서도 가능한 방법이다. (자세한 코드는 책 참고)
다만 OO 언어가 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했을 뿐이다.

여기까지만 보면 캡슐화에 대해서 OO 에는 점수를 줄 수 없고, 상속에 대해서도 0.5점뿐만 줄 수 있을 것 같다.

### 다형성
OO의 핵심은 다형성에 있다.

C 에서 다형적 행위를 행하기 위해서는 함수에 대한 포인터를 직접 사용해야 하는데, 이것은 위험하다.
OO 언어는 이런 위험을 없애주며, 다형적인 행위를 대수롭지 않은 행위로 간주할 수 있게 한다.
이를 통해 OO 는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론 지을 수 있다.

#### 의존성 역전
이 부분은 책을 다시 읽자.

### 결론
객체 지향이란 무엇인가?

소프트웨어 아키텍처 관점에서 정답은, 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

## 함수형 프로그래밍
함수형 프로그래밍이라는 개념 자체는 프로그래밍의 개념보다도 앞서 등장했다.
알론조 처치(Alonzo Church)가 1930년대 람다(lambda) 계산법을 발명했고, 이것이 함수형 프로그래밍 패러다임의 기반이 되었다.

정수를 제곱하는 두 개의 소스코드를 살펴보자.
```java
public class Squint() {
  public static void main(String[] args) {
    for (int i = 0; i < 25; i++) {
      System.out.println(i * i);
    }
  }
}
```

```Clojure
(println (take 25 (map (fn [x] (* x x)) (range))))
```

위 두 소스코드는 정확히 같은 동작을 한다.
이 둘 사이의 차이점은 뭘까? 바로 가변 변수(mutable variable)의 사용여부이다.
함수형 언어에서 변수는 변경되지 않는다.

### 불변성과 아키텍처
아키텍처를 고려하는데 이러한 내용이 왜 중요할까?
아키텍트는 왜 변수의 가변성을 염려할까?

경합 조건(race), 교착 상태 조건(deadlock), 동시 업데이트(concurrent update) 등의 문제는 모두 가변 변수로 인해 발생한다.
즉, 우리가 동시성 애플리케이션에서 마주하는 모든 문제는, 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주하는 모든 문제는 가변 변수로 인해 발생하고,
가변 변수가 없다면 절대로 발생하지 않는다.

아키텍트라면 동시성(concurrency)문제에 지대한 관심을 가져야만 한다.
우리는 스레드와 프로세스가 여러 개인 상황에서도 설계한 시스템이 여전히 강건하기를 바란다.

불변성이 정말로 실현 가능한가?
무한한 저장 공간과 무한히 빠른 속도를 지닌 프로세서를 전제한다면, 가능하다.
즉, 불가능하단 소리다. ㅋㅋ
그렇다면 우리는 타협을 해야한다.

### 가변성의 분리
애플리케이션 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하자.
불변 컴포넌트는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.
불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.

상태변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리(transaction memory)와 같은 실천법을 사용하여
동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.
하지만 해당 실천법을 구현하는 것은 꽤나 까다롭다. 현명한 아키텍트라면 가능한 많은 처리를 불변 컴포넌트로 옮기고 가변 컴포넌트에서는 가능한 많은 코드를 빼내야 한다.

### 이벤트 소싱
이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다.
상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.

예를 들어 고객의 계좌 잔고를 관리하는 은행 애플리케이션을 생각해보자.
입금 트랜잭션과 출금 트랜잭션을 매번 계산하는게 아니라, 트랜잭션 자체를 저장하는 것이다.
이후 계좌 잔액 상태가 필요할 때 해당 트랜잭션을 모두 계산하는 것이다.

데이터 저장소에 대해 생각해보자. 꽤 많은 저장 공간이 필요할텐데, 하드웨어의 발전으로 지금은 저장 공간의 한계를 느끼기 쉽지 않다.
따라서 우리는 저장 공간을 충분히 확보할 수 있다.

또한 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다. CRUD 중 CR만 수행한다. U가 없으니 동시 업데이트 문제 또한 일어나지 않는다.
저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있다. 따라서 완전한 함수형 애플리케이션이 가능하다.
터무니 없다고? 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다.

