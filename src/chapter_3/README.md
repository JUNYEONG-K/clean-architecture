# 설계 원칙
좋은 소프트웨어 시스템은 깔끔한 코드로부터 시작한다.
SOLID 원칙을 통해 깔끔한 코드를 작성해보자.

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법,그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.
SOLID 원칙의 목적은 중간 수준의 솦트웨어 구조가 아래와 같도록 만드는 데 있다.
* 변경에 유연하다.
* 이해하기 쉽다.
* 많은 소프트웨어 시스텡에 사용될 수 있는 컴포넌트의 기반이 된다.

중간 수준이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다.
즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는 데 도움을 준다.

## SRP: 단일 책임 원칙 Single Responsibility Principle
각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다. 그리고 그것은 분명 그 모듈의 책임이다.
다만, 이 말은 충분히 오해의 소지가 있다. 모든 모듈이 단 하나의 일만 해야한다고 오해하곤 한다.

단 하나의 일만 해야하는 것은 함수이다. 함수는 단 하나의 일만 수행하도록 작성되어야 한다.

SRP 를 재정의하면 아래와 같다.
> 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

Employee 라는 클래스에 calculatePay(), reportHours(), save() 3개의 메서드가 있다고 가정하자.
calculatePay() 메서드는 회계팀에서 기능을 활용할 것이다.
reportHours() 메서드는 인사팀에서 기능을 활용할 것이다.
save() 메서드는 DBA 가 기능을 활용할 것이다.

세 메서드를 Employee 라는 단일 클래스에 배치함으로써, 세 액터가 서로 결합되어 버렸다.
이 결합으로 인해 각 팀과 DBA 가 서로 의도치 않은 영향을 주거나 받을 가능성이 생겨버렸다.
이들이 각자 같은 메서드나 데이터에 영향을 준다면, 분명 의도치 않은 영향을 주고 받게 될 것이다.

코드를 작성하는 관점에서도 마찬가지이다. 각각의 액터는 각자의 요구사항 실현을 위해 Employee 클래스를 수정할 것이다.
이렇게 되면 병합 충돌이 발생할 수 있다.

따라서 SRP 는 이 문제를 해결하고자, 모듈은 하나의 액터에 대해서만 책임을 지도록 한다.

## OCP: 개방-폐쇄 원칙 Open-Closed Principle
기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다.
예전엔 이 원칙이 이해가 안갔다. 하지만 객체 지향에 관한 자료를 공부하면서부터 슬슬 이해가 간다.
인터페이스의 구현체를 추가함으로써 추가적인 요청사항에 대응하는 것이다.

> 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다는 것이다.
이는 소프트웨어 아키텍처를 공부하는 가장 근본적인 이유이다.
만약 요구사항을 살짝 확장하는 데 소프트웨어를 엄청나게 수정해야 한다면, 그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패를 맞닥뜨린 것이다.

### 사고 실험 Thought Experiment
음.. 이 뒤는 꽤 어렵다. 다시 보자! TODO



## LSP: 리스코프 치환 원칙 Liskov Substitution Principle
상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다.

1988년 바바라 리스코프(Barbara Liskov)는 하위 타입(subtype)을 아래와 같이 정의 했다.

```
S 타입의 객체 o1 각각에 대응하는 T 타입의 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2 자리에 o1을 치환하더라도 
P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
```

```java
public interface T {}
public interface S extends T {}

T o1 = new T();
T o2 = new S();
```

LSP 는 잘 정의된 인터페이스와 그 인터페이스의 구현체끼리의 상호 치환 가능성을 제시한다.
인터페이스에 의존하도록 만드는 것이다.

LSP 를 이해하는 최선의 방법은 이 원칙을 어겼을 때, 시스템 아키텍처에서 무슨 일이 일어나는지를 관찰하면 된다.

### LSP 위반 사례
다양한 택시 파견 서비스를 통합하는 애플리케이션을 가정하자.
`purplecab` 이라는 회사에 요청을 보내는 URI 가 다음과 같다.
`purplecab.com/driver/Bob/pickupAddress/24 Maple St./pickupTime/153/destination/ORD`

우리가 만들고자 하는 애플리케이션은 다양한 택시 파견 서비스를 통합하는 것이기 때문에, 각 서비스들은 위 REST 원칙을 지켜야 한다.
즉, 인터페이스를 제대로 구현해야 한다.

만약 `acme` 라는 회사에서 이를 지키지 않고, destination 을 dest 라는 키워드로 사용하면 어떻게 될까?
우리 애플리케이션에서는 예외 처리가 필요해진다.

```java
if (driver.getDispatchUri().startsWith("acme.com")) {}
```
각 서비스의 도메인 주소만 변경하면 되는 치환 가능성을 없애버렸다.

LSP 는 아키텍처 수준까지 확장해야 한다.
치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 매커니즘을 추가해야 할 수 있기 때문이다.

## ISP: 인터페이스 분리 원칙 Interface Segregation Principle
소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.

이 부분은 책에 그림과 함께 더 자세히 설명이 되어 있어서 따로 기재하지 않겠다.
요지는, 사용하지 않는 것에 의존을 하게 되면, 관련 없는 수정에도 불구하고 영향을 받게 되는 모듈이 있다는 것이다.
이로 인한 재컴파일, 재배포 등의 불필요한 행위가 필요해진다.

## DIP: 의존성 역전 원칙 Dependency Inversion Principle
고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다.
대신 세부사항이 정책에 의존해야 한다.

DIP 에서 말하는 '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.
자바와 같은 정적 타입 언어에서 이 말은 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이다.
구체적인 대상에는 절대로 의존해서는 안 된다.

물론 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 이 규칙을 무시하는 편이다. 너무나 안정적인 구현체이기 때문이다.
우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소이다.

### 안정된 추상화
추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들은 필연적으로 수정이 필요하다.
반대로 구현체에는 변경이 생기더라도 인터페이스가 변경될 일은 거의 없다.
인터페이스는 구현체보다 변동성이 낮다.

인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾는 것이 소프트웨어 설계의 기본이다.
안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.

이를 위한 몇 가지 실천법이 있다.
* 변동성이 큰 구체 클래스를 참조하지 말라. 대신 추상 인터페이스를 참조하라.
* 변동성이 큰 구체 클래스로부터 파생하지 말라.
* 구체 함수를 오버라이드 하지 말라. 구체 함수 오버라이드는 의존성을 상속하게 만든다. 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해라.
* 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

### 팩토리
위 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다.
객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생하기 때문이다.
아래처럼 말이다!
```java
import 구체클래스;

public class A {
    구체클래스 a = new 구체클래스();
}
```

이런 바람직하지 못한 의존성을 처리할 때 추상팩토리를 사용하곤 한다.
책 94 페이지의 그림을 보는 것이 자세한 이해를 돕는다. 

팩토리를 사용해, 구체적인 부분과 추상화 부분의 경계를 구분지어야 한다. 추상 컴포넌트와 구체 컴포넌트로 분리하는 것이다.
추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다. 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.

이때 제어흐름은 소스코드 의존성과는 정반대 방향이다. 이것이 의존성 역전이다.
