# 아키텍처
소프트웨어 아키텍트는 프로그래머이며, 앞으로도 프로그래머로 남는다. 
소프트웨어 아키텍트라면 코드에서 탈피하여 ㅗ수준의 문제에 집중해야 한다는 거짓말에 절대로 속아 넘어가서는 안 된다.

소프트웨어 시스템의 아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태다. 
그 모양은 시스템을 컴포넌트로 분리하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다.
그리고 그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.

> 이러한 일을 용이하게 만들기 위해서는 가능한 한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야 한다.

아키텍처는 동작과는 대게 관련이 없다. 아키텍처가 엉망이어도 동작하는 시스템은 많다.
이들은 주로 배포, 유지보수 과정에서 어려움을 겪는다.

아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다.
좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 또 쉽게 배포하게 해준다.
아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.

각각의 측면에서 아키텍쳐에 대해 생각해보자.
* 개발
  * 팀 구성마다 다르겠다. 적은 팀원으로 구성된 소규모 개발팀이라면 오히려 아키텍처가 제약으로 느껴져 개발에 불편함을 느낄지 모른다.
  * 많은 팀원으로 구성된 규모가 있는 개발팀이라면, 제약을 둠으로써 개발에 용이함을 가져갈 수 있다.
* 배포
  * 초기 개발 단계에서는 배포 전략을 거의 고려하지 않는다.
  * 만약 개발 초기 단계에 마이크로서비스 아키텍처를 선택했다면, 컴포넌트 경계가 매우 뚜렷해지고 인터페이스가 대체로 안정화되므로 시스템을 매우 쉽게 개발할 수 있다는 이점이 있다.
  * 하지만, 배포할 시기가 되면 위협적일 만큼 늘어난 수많은 마이크로서비스를 발견하게 될지도 모른다.
  * 마이크로서비스들은 서로 연결하기 위해 설정하고 작동 순서를 결정하는 과정에서 오작동이 발생할 원천이 스며들 수도 있기 때문이다.
* 운영
  * 아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향에 비하면 덜 극적이다.
  * 대게 아케틱처와 무관하게 하드웨어 투입으로 해결을 한다.
* 유지보수
  * 유지보수는 모든 측면에서 봤을 때 소프트웨어 시스템에서 비용이 가장 많이 든다.
  * 끝도 없는 새로운 기능, 이로 인한 결함, 결함을 수정하는 데 드는 자원 ...
  * 유지보수의 가장 큰 비용은 탐사와 이로 인한 위험부담에 있다.
  * 이런 위험부담을 아키텍처를 활용해 '크게' 줄일 수 있다.
  * 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리하자.
  * 이를 통해 미래에 추가될 기능에 대한 길을 밝혀 둘 수 있을 뿐만 아니라 의도치 않은 장애가 발생할 위험을 크게 줄일 수 있다.
* 선택사항 열어 두기
  * 소프트웨어는 두 종류의 가치, 즉 행위적 가치와 구조적 가치를 지닌다. 이 중에서 두 번째 가치가 더 중요한데, 소프트웨어를 부드럽게 만드는 것은 바로 이 구조적 가치이기 때문이다.
  * 소프트웨어의 유연성은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트가 상호 연결되는 방식에 상당히 크게 의존한다.
  * 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 그리고 가능한 한 오래 열어두는 것이다. (이때 선택사항이란, 중요치 않은 세부사항이다.)
  * 소프트웨어 시스템은 정책과 세부사항, 두 가지 구성요소로 분해할 수 있다.
  * 정책: 모든 업무 규칙과 업무 절차를 구체화하여, 시스템의 진정한 가치가 살아있는 곳
  * 세부사항: 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등 프로그래머가 정책과 소통할 때 필요한 요소 (정책이 가진 행위에는 조금도 영향을 미치지 않음.)
  * 아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 시스템을 구축하는 데 있다. 이를 통해 세부사항을 결정하는 일은 미루거나 연기할 수 있게 된다.
  * 세부사항에 대한 결정을 더 오래 참으면 참을 수록, 좋은 아키텍처를 만들 수 있을 것이다.
> 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.

# 독립성
좋은 아키첵처는 다음을 지원해야 한다.
* 시스템의 유스케이스
* 시스템의 운영
* 시스템의 개발
* 시스템의 배포

## 유스케이스
만약 시스템이 장바구니 애플리케이션이라면, 이 아키텍처는 장바구니와 관련된 유스케이스를 지원해야 한다.
아키텍트의 최우선 관심사는 유스케이스이며, 아키텍처에서도 유스케이스가 최우선이다.

물론 아키텍처는 시스템의 행위에 그다지 큰 영향을 주지는 않는다.
하지만 영향력이 전부는 아니다.
좋은 아키텍처는 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만든다.
장바구니 애플리케이션이 좋은 아키텍처를 갖춘다면, 이 애플리케이션은 장바구니 애플리케이션처럼 보일 것이다.

## 운영
시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜피상적인 역할을 맡는다.
시스템이 초당 100,000명의 고객을 처리해야 한다면, 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 한다.

어떤 시스템에서는 시스템의 처리 요소를 일련의 작은 서비스들로 배열하여, 서로 다른 많은 서버에서 병렬로 실행할 수 있게 만든다.
또 다른 시스템에서는 경량의 수많은 스레드가 단일 프로세서에서 같은 주소 공간을 공유하도록 만든다.
또는 독립된 주소 공간에서 실행되는 소수의 프로세스만으로도 충분한 시스템이 있다.
심지어 어떤 시스템은 단일 프로세서에서 실행되는 단순한 모놀리틱 프로그램 정도로 살아남기도 한다.

이러한 결정은 뛰어난 아키텍트라면 열어 두어야 하는 선택사항 주으이 하나이다.
만약 시스템이 단일체(monolith)로 작성되어 모놀리틱 구조를 갖는다면, 다중 프로세스, 다중 스레드 또는 마이크로서비스 형태가 필요해질 때 개선하기가 어렵다.
그에 비해 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.

## 개발
아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할을 수행한다.
그리고 여기서 콘웨이의 법칙이 적용된다.
> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로 방해하지 않도록 해야 한다.
이를 위해서는 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할할 수 있어야 한다.
그래야만 이들 컴포넌트를 독립적으로 작업할 수 있는 팀에 할당할 수 있다.

## 배포
아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다.
목표는 `즉각적인 배포`이다.
좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.
이를 위해서는 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다.

## 선택사항 열어놓기
좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시킨다.
하지만 이 균형을 현실세계에서 잡는 것은 꽤나 어렵다.
그래도 우리는 이러한 목표를 잊지 말고, 시스템을 격리된 컴포넌트 단위로 분할하고 선택사항을 가능한 한 많이, 오래 열어두자.

> 좋은 아키텍처는 선택사항을 열어둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

## 계층 결합 분리
아키텍트는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만, 유스케이스 전부를 알지는 못한다.
하지만 아키텍트는 그 시스템이 장바구니 시스템인지, 자재 명세서 시스템인지, 또는 주문 처리 시스템인지는 알고 있다. 그리고 아키텍처는 그것을 명시해야한다.
따라서 아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들을 분리하고, 동일한 이유로 변경되는 것들을 묶는다.

아키텍트는 변경되는 것들을 분리하여 독립적으로 변경할 수 있도록 해야 한다.
시스템을 서로 결합되지 않은 수평적인 계층으로 분리해야 한다.

## 유스케이스 결합 분리
계층 분리는 시스템을 수평적으로 분리한다. (책 161 페이지 참고)
반면 유스케이스 분리는 시스템을 수직적으로 분리한다. 즉 모든 계층에 걸친다는 말이다.

유스케이스가 변경 혹은 추가되는 경우를 살펴보자.
주문 입력 시스템에서 주문을 추가하는 유스케이스와 주문을 삭제하는 유스케이스는 독립적으로 동작할 것이다.
주문을 추가하는 유스케이스만 있는 시스템에 주문을 삭제하는 유스케이스를 추가하는 것은, 각 계층에 소스 코드 추가를 일으킬 것이다.

시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있게 된다.
새로운 유스케이스 추가가 기존 유스케이스에 영향을 주는 일 또한 거의 없을 것이다.

## 결합 분리
위 두 결합 분리는 궁극적으로 다음을 말하는 것이다.
좋은 아키텍처는 선택권을 열어 둔다.

계층 분리는 개발 독립성, 배포 독립성의 이점을 가져다 준다.

결합은 중복을 만들어낼 수 있다. 개발에서 중복은 기본적으로 나쁘다.
다만 우리는 이제 이 중복이 진짜 중복인지, 우발적 중복인지 구분해야 한다.
굉장히 유사한 유스케이스를 예로 들자. 서로 비슷한 화면 구조, 비슷한 알고리즘, 비슷한 데이터베이스 쿼리와 스키마를 가질 것이다.
이들을 그럼 통합해야 할까? 이드은 분명 서로 다른 시간에 서로 다른 이유로 수정될 것이며, 시간이 지날수록 각각의 형태가 달라질 것이다.
섣불리 중복을 통합했다가는 후에 분리하는 수고로움을 겪어야 한다.
중복된 코드이더라도 분리된 컴포넌트라면, 우발적 중복일 확률이 높다.
결합과 분리를 적절히 이뤄내자.

# 경계: 선 긋기
소프트웨어 아키텍처는 선을 긋는 기술이며, 이 선을 경계(boundary)라고 부른다.
경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다.
이들 선 중 일부는 프로젝트 수명 중 아주 초기에, 심지어 코드가 전혀 작성되기도 전에 그어지며, 어떤 선은 매우 나중에 그어진다.
초기에 그어지는 선들은 가능한 한 오랫동안 결정을 연기시키기 위해, 그래서 이들 결정이 핵심적인 업무 로직을 오염시키지 못하게 만들려는 목적으로 쓰인다.

아키텍트의 목표는 필요한 시스템을 만들고 유지하는 데 드는 인적 자원을 최소화하는 것이다.
인적 자원의 효율을 떨어뜨리는 요인이 바로 `결합 coupling` 이다.
특히 너무 일찍 내려진 결정에 따른 결합이다.

그럼 어떤 결정이 이른 결정일까? 바로 시스템의 업무 요구사항, 즉 유스케이스와 아무런 관련이 없는 결정이다.
프레임워크, 데이터베이스, 웹 서버, 유틸리티 라이브러리, 의존성 주입에 대한 결정 등이 여기 포함된다.
좋은 시스템 아키텍처란 이러한 결정이 부수적이며, 결정을 연기할 수 있는 아키텍처이다.
좋은 시스템 아키텍처는 이런 결정에 의존하지 않는다.
좋은 시스템 아키텍처는 이러한 결정을 가능한 한 최후의 순간에 내릴 수 있게 해주며, 결정에 따른 영향이 크지 않게 만든다.

## 저자의 Fitnesse 프로젝트 일화
책의 173 페이지에 저자가 직접 경험한 Fitnesse 프로젝트에 관한 일화가 있다.
굉장히 좋은 일화인 것 같다. 꼭 여러 번 읽어보자.

`경계: 선 긋기` 장은 그림을 활용해서 설명을 한다. 중요한 내용이 많다. 책을 꼭 한 번 다시 보자.

결론은, 소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다.
일부 컴포넌트는 핵심 업무 규칙에 해당한다. 나머지 컴포넌트는 플러그인으로, 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다.
그런 다음 컴포넌트 사이의 화살표가 특정 방향, 즉 핵심 업무를 향하도록 이들 컴포넌트의 소스를 배치한다.
화살표를 핵심 업무를 향하도록 하는 것은, 세부사항들이 핵심 업무에 의존하도록, 핵심 업무는 세부사항의 존재를 알지 않도록 하는 것이다.

이는 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것이다. 의존성 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치하자.

# 경계 해부학
시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.

## 경계 횡단하기
`런타임에 경계를 횡단한다.`라는 말은 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다.
적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.

# 정책과 수준
책을 읽어보자... 정리하기 애매하네. 그림들이랑 같이 설명되어있어서;;

# 업무 규칙
업무 규칙은 소프트웨어 시스템이 존재하는 이유다.
업무 규칙은 핵심적인 기능으로, 수익을 내고 비용을 줄이는 코드를 수반한다.
이는 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안 되며, 원래 그대로의 모습으로 남아 있어야 한다.
이상적으로는 업무 규칙을 표현하는 코드는 반드시 시스템의 심장부에 위치해야 하며, 덜 중요한 코드는 이 심장부에 플러그인되어야 한다.
업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.

# 소리치는 아키텍처
헬스 케어 시스템의 소프트웨어 아키텍처는 이것이 헬스 케어 시스템이야!! 라고 소리쳐야 한다.
스프링이야! 레일스야! 와 같이 프레임워크에 대해 소리치고 있지는 않은가? 고민해보자.

소프트웨어 애플리케이션의 아키텍처는 애플리케이션의 유스케이스를 뚜렷이 나타내야 한다.
프레임워크 중심이 아닌 유스케이스 중심이 되어야 한다.

좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에, 프레임워크나 도구, 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 아무런 문제 없이 기술할 수 있어야 한다.
좋은 소프트웨어 아키텍처는 프레임워크, 데이터베이스, 웹 서버, 그리고 여타 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있도록 만든다.
프레임워크는 열어 둬야 할 선택사항이다. 

아키텍처는 시스템을 이야기해야 하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안 된다.
아키텍처는 유스케이스를 최우선해야 한다.
물론 프레임워크는 매우 강력하고 상당히 유용하다.
그래도 프레임워크와 적당한 거리를 두자. 프레임워크와 적당히 거리를 두고, 유스케이스를 최우선으로 하면, 테스트에 용이한 아키텍처를 가질 수 있다.

# 클린 아키텍처
> 엔티티 <- 유스케이스 <- 인터페이스 어댑터 (컨트롤러, 뷰 등) <- 프레임워크와 드라이버

소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.
왼쪽으로 갈수록 고수준 정책이다.
왼쪽의 요소는 오른쪽 요소에 속한 어떤 것도 알지 못한다.
왼쪽으로 이동할 수록 추상화와 정책의 수준은 높아진다. 오른쪽으로 갈 수록 구체적인 세부사항이다.
왼쪽으로 갈 수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을 캡슐화한다.
따라서 가장 왼쪽은 가장 범용적이며 높은 수준을 가진다.

경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야만 한다.

소프트웨어를 계층으로 분리하고 위 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 따른 이점을 누릴 수 있다.

# 프레젠터와 험블 객체

